<?php
/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/zipkinCore/zipkinCore_types.php';
include_once $GLOBALS['THRIFT_ROOT'].'/packages/zipkinDependencies/zipkinDependencies_types.php';

$GLOBALS['E_Order'] = array(
  'TIMESTAMP_DESC' => 0,
  'TIMESTAMP_ASC' => 1,
  'DURATION_ASC' => 2,
  'DURATION_DESC' => 3,
  'NONE' => 4,
);

final class Order {
  const TIMESTAMP_DESC = 0;
  const TIMESTAMP_ASC = 1;
  const DURATION_ASC = 2;
  const DURATION_DESC = 3;
  const NONE = 4;
  static public $__names = array(
    0 => 'TIMESTAMP_DESC',
    1 => 'TIMESTAMP_ASC',
    2 => 'DURATION_ASC',
    3 => 'DURATION_DESC',
    4 => 'NONE',
  );
}

$GLOBALS['E_Adjust'] = array(
  'NOTHING' => 0,
  'TIME_SKEW' => 1,
);

final class Adjust {
  const NOTHING = 0;
  const TIME_SKEW = 1;
  static public $__names = array(
    0 => 'NOTHING',
    1 => 'TIME_SKEW',
  );
}

class Trace {
  static $_TSPEC;

  public $spans = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'spans',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Span',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['spans'])) {
        $this->spans = $vals['spans'];
      }
    }
  }

  public function getName() {
    return 'Trace';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->spans = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new Span();
              $xfer += $elem5->read($input);
              $this->spans []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Trace');
    if ($this->spans !== null) {
      if (!is_array($this->spans)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spans', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->spans));
        {
          foreach ($this->spans as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryException extends TException {
  static $_TSPEC;

  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'QueryException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TraceSummary {
  static $_TSPEC;

  public $trace_id = null;
  public $start_timestamp = null;
  public $end_timestamp = null;
  public $duration_micro = null;
  public $service_counts = null;
  public $endpoints = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_id',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'start_timestamp',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'end_timestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'duration_micro',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'service_counts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        6 => array(
          'var' => 'endpoints',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Endpoint',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_id'])) {
        $this->trace_id = $vals['trace_id'];
      }
      if (isset($vals['start_timestamp'])) {
        $this->start_timestamp = $vals['start_timestamp'];
      }
      if (isset($vals['end_timestamp'])) {
        $this->end_timestamp = $vals['end_timestamp'];
      }
      if (isset($vals['duration_micro'])) {
        $this->duration_micro = $vals['duration_micro'];
      }
      if (isset($vals['service_counts'])) {
        $this->service_counts = $vals['service_counts'];
      }
      if (isset($vals['endpoints'])) {
        $this->endpoints = $vals['endpoints'];
      }
    }
  }

  public function getName() {
    return 'TraceSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->start_timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->duration_micro);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->service_counts = array();
            $_size7 = 0;
            $_ktype8 = 0;
            $_vtype9 = 0;
            $xfer += $input->readMapBegin($_ktype8, $_vtype9, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $key12 = '';
              $val13 = 0;
              $xfer += $input->readString($key12);
              $xfer += $input->readI32($val13);
              $this->service_counts[$key12] = $val13;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->endpoints = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $elem19 = new Endpoint();
              $xfer += $elem19->read($input);
              $this->endpoints []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TraceSummary');
    if ($this->trace_id !== null) {
      $xfer += $output->writeFieldBegin('trace_id', TType::I64, 1);
      $xfer += $output->writeI64($this->trace_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->start_timestamp !== null) {
      $xfer += $output->writeFieldBegin('start_timestamp', TType::I64, 2);
      $xfer += $output->writeI64($this->start_timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_timestamp !== null) {
      $xfer += $output->writeFieldBegin('end_timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->end_timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->duration_micro !== null) {
      $xfer += $output->writeFieldBegin('duration_micro', TType::I32, 4);
      $xfer += $output->writeI32($this->duration_micro);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->service_counts !== null) {
      if (!is_array($this->service_counts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('service_counts', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->service_counts));
        {
          foreach ($this->service_counts as $kiter20 => $viter21)
          {
            $xfer += $output->writeString($kiter20);
            $xfer += $output->writeI32($viter21);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endpoints !== null) {
      if (!is_array($this->endpoints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('endpoints', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->endpoints));
        {
          foreach ($this->endpoints as $iter22)
          {
            $xfer += $iter22->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TimelineAnnotation {
  static $_TSPEC;

  public $timestamp = null;
  public $value = null;
  public $host = null;
  public $span_id = null;
  public $parent_id = null;
  public $service_name = null;
  public $span_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'host',
          'type' => TType::STRUCT,
          'class' => 'Endpoint',
          ),
        4 => array(
          'var' => 'span_id',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'parent_id',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'span_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['span_id'])) {
        $this->span_id = $vals['span_id'];
      }
      if (isset($vals['parent_id'])) {
        $this->parent_id = $vals['parent_id'];
      }
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['span_name'])) {
        $this->span_name = $vals['span_name'];
      }
    }
  }

  public function getName() {
    return 'TimelineAnnotation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->host = new Endpoint();
            $xfer += $this->host->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->span_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->parent_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->span_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TimelineAnnotation');
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      if (!is_object($this->host)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('host', TType::STRUCT, 3);
      $xfer += $this->host->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->span_id !== null) {
      $xfer += $output->writeFieldBegin('span_id', TType::I64, 4);
      $xfer += $output->writeI64($this->span_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parent_id !== null) {
      $xfer += $output->writeFieldBegin('parent_id', TType::I64, 5);
      $xfer += $output->writeI64($this->parent_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 6);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->span_name !== null) {
      $xfer += $output->writeFieldBegin('span_name', TType::STRING, 7);
      $xfer += $output->writeString($this->span_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TraceTimeline {
  static $_TSPEC;

  public $trace_id = null;
  public $root_most_span_id = null;
  public $annotations = null;
  public $binary_annotations = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_id',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'root_most_span_id',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'annotations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TimelineAnnotation',
            ),
          ),
        7 => array(
          'var' => 'binary_annotations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'BinaryAnnotation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_id'])) {
        $this->trace_id = $vals['trace_id'];
      }
      if (isset($vals['root_most_span_id'])) {
        $this->root_most_span_id = $vals['root_most_span_id'];
      }
      if (isset($vals['annotations'])) {
        $this->annotations = $vals['annotations'];
      }
      if (isset($vals['binary_annotations'])) {
        $this->binary_annotations = $vals['binary_annotations'];
      }
    }
  }

  public function getName() {
    return 'TraceTimeline';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->root_most_span_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->annotations = array();
            $_size23 = 0;
            $_etype26 = 0;
            $xfer += $input->readListBegin($_etype26, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $elem28 = null;
              $elem28 = new TimelineAnnotation();
              $xfer += $elem28->read($input);
              $this->annotations []= $elem28;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->binary_annotations = array();
            $_size29 = 0;
            $_etype32 = 0;
            $xfer += $input->readListBegin($_etype32, $_size29);
            for ($_i33 = 0; $_i33 < $_size29; ++$_i33)
            {
              $elem34 = null;
              $elem34 = new BinaryAnnotation();
              $xfer += $elem34->read($input);
              $this->binary_annotations []= $elem34;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TraceTimeline');
    if ($this->trace_id !== null) {
      $xfer += $output->writeFieldBegin('trace_id', TType::I64, 1);
      $xfer += $output->writeI64($this->trace_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->root_most_span_id !== null) {
      $xfer += $output->writeFieldBegin('root_most_span_id', TType::I64, 2);
      $xfer += $output->writeI64($this->root_most_span_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->annotations !== null) {
      if (!is_array($this->annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('annotations', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->annotations));
        {
          foreach ($this->annotations as $iter35)
          {
            $xfer += $iter35->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_annotations !== null) {
      if (!is_array($this->binary_annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('binary_annotations', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->binary_annotations));
        {
          foreach ($this->binary_annotations as $iter36)
          {
            $xfer += $iter36->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TraceCombo {
  static $_TSPEC;

  public $trace = null;
  public $summary = null;
  public $timeline = null;
  public $span_depths = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace',
          'type' => TType::STRUCT,
          'class' => 'Trace',
          ),
        2 => array(
          'var' => 'summary',
          'type' => TType::STRUCT,
          'class' => 'TraceSummary',
          ),
        3 => array(
          'var' => 'timeline',
          'type' => TType::STRUCT,
          'class' => 'TraceTimeline',
          ),
        4 => array(
          'var' => 'span_depths',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace'])) {
        $this->trace = $vals['trace'];
      }
      if (isset($vals['summary'])) {
        $this->summary = $vals['summary'];
      }
      if (isset($vals['timeline'])) {
        $this->timeline = $vals['timeline'];
      }
      if (isset($vals['span_depths'])) {
        $this->span_depths = $vals['span_depths'];
      }
    }
  }

  public function getName() {
    return 'TraceCombo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->trace = new Trace();
            $xfer += $this->trace->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->summary = new TraceSummary();
            $xfer += $this->summary->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->timeline = new TraceTimeline();
            $xfer += $this->timeline->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->span_depths = array();
            $_size37 = 0;
            $_ktype38 = 0;
            $_vtype39 = 0;
            $xfer += $input->readMapBegin($_ktype38, $_vtype39, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $key42 = 0;
              $val43 = 0;
              $xfer += $input->readI64($key42);
              $xfer += $input->readI32($val43);
              $this->span_depths[$key42] = $val43;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TraceCombo');
    if ($this->trace !== null) {
      if (!is_object($this->trace)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace', TType::STRUCT, 1);
      $xfer += $this->trace->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary !== null) {
      if (!is_object($this->summary)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('summary', TType::STRUCT, 2);
      $xfer += $this->summary->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timeline !== null) {
      if (!is_object($this->timeline)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('timeline', TType::STRUCT, 3);
      $xfer += $this->timeline->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->span_depths !== null) {
      if (!is_array($this->span_depths)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('span_depths', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::I64, TType::I32, count($this->span_depths));
        {
          foreach ($this->span_depths as $kiter44 => $viter45)
          {
            $xfer += $output->writeI64($kiter44);
            $xfer += $output->writeI32($viter45);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryRequest {
  static $_TSPEC;

  public $service_name = null;
  public $span_name = null;
  public $annotations = null;
  public $binary_annotations = null;
  public $end_ts = null;
  public $limit = null;
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'span_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'annotations',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'binary_annotations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'BinaryAnnotation',
            ),
          ),
        5 => array(
          'var' => 'end_ts',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'limit',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['span_name'])) {
        $this->span_name = $vals['span_name'];
      }
      if (isset($vals['annotations'])) {
        $this->annotations = $vals['annotations'];
      }
      if (isset($vals['binary_annotations'])) {
        $this->binary_annotations = $vals['binary_annotations'];
      }
      if (isset($vals['end_ts'])) {
        $this->end_ts = $vals['end_ts'];
      }
      if (isset($vals['limit'])) {
        $this->limit = $vals['limit'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'QueryRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->span_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->annotations = array();
            $_size46 = 0;
            $_etype49 = 0;
            $xfer += $input->readListBegin($_etype49, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $elem51 = null;
              $xfer += $input->readString($elem51);
              $this->annotations []= $elem51;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->binary_annotations = array();
            $_size52 = 0;
            $_etype55 = 0;
            $xfer += $input->readListBegin($_etype55, $_size52);
            for ($_i56 = 0; $_i56 < $_size52; ++$_i56)
            {
              $elem57 = null;
              $elem57 = new BinaryAnnotation();
              $xfer += $elem57->read($input);
              $this->binary_annotations []= $elem57;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->limit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryRequest');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->span_name !== null) {
      $xfer += $output->writeFieldBegin('span_name', TType::STRING, 2);
      $xfer += $output->writeString($this->span_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->annotations !== null) {
      if (!is_array($this->annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('annotations', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->annotations));
        {
          foreach ($this->annotations as $iter58)
          {
            $xfer += $output->writeString($iter58);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_annotations !== null) {
      if (!is_array($this->binary_annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('binary_annotations', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->binary_annotations));
        {
          foreach ($this->binary_annotations as $iter59)
          {
            $xfer += $iter59->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_ts !== null) {
      $xfer += $output->writeFieldBegin('end_ts', TType::I64, 5);
      $xfer += $output->writeI64($this->end_ts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limit !== null) {
      $xfer += $output->writeFieldBegin('limit', TType::I32, 6);
      $xfer += $output->writeI32($this->limit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 7);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class QueryResponse {
  static $_TSPEC;

  public $trace_ids = null;
  public $start_ts = null;
  public $end_ts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'start_ts',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'end_ts',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
      if (isset($vals['start_ts'])) {
        $this->start_ts = $vals['start_ts'];
      }
      if (isset($vals['end_ts'])) {
        $this->end_ts = $vals['end_ts'];
      }
    }
  }

  public function getName() {
    return 'QueryResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size60 = 0;
            $_etype63 = 0;
            $xfer += $input->readListBegin($_etype63, $_size60);
            for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
            {
              $elem65 = null;
              $xfer += $input->readI64($elem65);
              $this->trace_ids []= $elem65;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->start_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('QueryResponse');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter66)
          {
            $xfer += $output->writeI64($iter66);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->start_ts !== null) {
      $xfer += $output->writeFieldBegin('start_ts', TType::I64, 2);
      $xfer += $output->writeI64($this->start_ts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_ts !== null) {
      $xfer += $output->writeFieldBegin('end_ts', TType::I64, 3);
      $xfer += $output->writeI64($this->end_ts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
