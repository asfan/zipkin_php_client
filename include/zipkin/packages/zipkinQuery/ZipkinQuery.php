<?php
/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/zipkinQuery/zipkinQuery_types.php';

interface ZipkinQueryIf {
  public function getTraceIds($request);
  public function getTraceIdsBySpanName($service_name, $span_name, $end_ts, $limit, $order);
  public function getTraceIdsByServiceName($service_name, $end_ts, $limit, $order);
  public function getTraceIdsByAnnotation($service_name, $annotation, $value, $end_ts, $limit, $order);
  public function tracesExist($trace_ids);
  public function getTracesByIds($trace_ids, $adjust);
  public function getTraceTimelinesByIds($trace_ids, $adjust);
  public function getTraceSummariesByIds($trace_ids, $adjust);
  public function getTraceCombosByIds($trace_ids, $adjust);
  public function getServiceNames();
  public function getSpanNames($service_name);
  public function setTraceTimeToLive($trace_id, $ttl_seconds);
  public function getTraceTimeToLive($trace_id);
  public function getDataTimeToLive();
  public function getDependencies($start_time, $end_time);
  public function getTopAnnotations($service_name);
  public function getTopKeyValueAnnotations($service_name);
}

class ZipkinQueryClient implements ZipkinQueryIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function getTraceIds($request)
  {
    $this->send_getTraceIds($request);
    return $this->recv_getTraceIds();
  }

  public function send_getTraceIds($request)
  {
    $args = new ZipkinQuery_getTraceIds_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceIds', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceIds', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceIds()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceIds_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceIds_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceIds failed: unknown result");
  }

  public function getTraceIdsBySpanName($service_name, $span_name, $end_ts, $limit, $order)
  {
    $this->send_getTraceIdsBySpanName($service_name, $span_name, $end_ts, $limit, $order);
    return $this->recv_getTraceIdsBySpanName();
  }

  public function send_getTraceIdsBySpanName($service_name, $span_name, $end_ts, $limit, $order)
  {
    $args = new ZipkinQuery_getTraceIdsBySpanName_args();
    $args->service_name = $service_name;
    $args->span_name = $span_name;
    $args->end_ts = $end_ts;
    $args->limit = $limit;
    $args->order = $order;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceIdsBySpanName', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceIdsBySpanName', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceIdsBySpanName()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceIdsBySpanName_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceIdsBySpanName_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceIdsBySpanName failed: unknown result");
  }

  public function getTraceIdsByServiceName($service_name, $end_ts, $limit, $order)
  {
    $this->send_getTraceIdsByServiceName($service_name, $end_ts, $limit, $order);
    return $this->recv_getTraceIdsByServiceName();
  }

  public function send_getTraceIdsByServiceName($service_name, $end_ts, $limit, $order)
  {
    $args = new ZipkinQuery_getTraceIdsByServiceName_args();
    $args->service_name = $service_name;
    $args->end_ts = $end_ts;
    $args->limit = $limit;
    $args->order = $order;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceIdsByServiceName', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceIdsByServiceName', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceIdsByServiceName()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceIdsByServiceName_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceIdsByServiceName_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceIdsByServiceName failed: unknown result");
  }

  public function getTraceIdsByAnnotation($service_name, $annotation, $value, $end_ts, $limit, $order)
  {
    $this->send_getTraceIdsByAnnotation($service_name, $annotation, $value, $end_ts, $limit, $order);
    return $this->recv_getTraceIdsByAnnotation();
  }

  public function send_getTraceIdsByAnnotation($service_name, $annotation, $value, $end_ts, $limit, $order)
  {
    $args = new ZipkinQuery_getTraceIdsByAnnotation_args();
    $args->service_name = $service_name;
    $args->annotation = $annotation;
    $args->value = $value;
    $args->end_ts = $end_ts;
    $args->limit = $limit;
    $args->order = $order;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceIdsByAnnotation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceIdsByAnnotation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceIdsByAnnotation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceIdsByAnnotation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceIdsByAnnotation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceIdsByAnnotation failed: unknown result");
  }

  public function tracesExist($trace_ids)
  {
    $this->send_tracesExist($trace_ids);
    return $this->recv_tracesExist();
  }

  public function send_tracesExist($trace_ids)
  {
    $args = new ZipkinQuery_tracesExist_args();
    $args->trace_ids = $trace_ids;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'tracesExist', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('tracesExist', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_tracesExist()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_tracesExist_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_tracesExist_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("tracesExist failed: unknown result");
  }

  public function getTracesByIds($trace_ids, $adjust)
  {
    $this->send_getTracesByIds($trace_ids, $adjust);
    return $this->recv_getTracesByIds();
  }

  public function send_getTracesByIds($trace_ids, $adjust)
  {
    $args = new ZipkinQuery_getTracesByIds_args();
    $args->trace_ids = $trace_ids;
    $args->adjust = $adjust;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTracesByIds', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTracesByIds', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTracesByIds()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTracesByIds_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTracesByIds_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTracesByIds failed: unknown result");
  }

  public function getTraceTimelinesByIds($trace_ids, $adjust)
  {
    $this->send_getTraceTimelinesByIds($trace_ids, $adjust);
    return $this->recv_getTraceTimelinesByIds();
  }

  public function send_getTraceTimelinesByIds($trace_ids, $adjust)
  {
    $args = new ZipkinQuery_getTraceTimelinesByIds_args();
    $args->trace_ids = $trace_ids;
    $args->adjust = $adjust;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceTimelinesByIds', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceTimelinesByIds', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceTimelinesByIds()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceTimelinesByIds_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceTimelinesByIds_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceTimelinesByIds failed: unknown result");
  }

  public function getTraceSummariesByIds($trace_ids, $adjust)
  {
    $this->send_getTraceSummariesByIds($trace_ids, $adjust);
    return $this->recv_getTraceSummariesByIds();
  }

  public function send_getTraceSummariesByIds($trace_ids, $adjust)
  {
    $args = new ZipkinQuery_getTraceSummariesByIds_args();
    $args->trace_ids = $trace_ids;
    $args->adjust = $adjust;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceSummariesByIds', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceSummariesByIds', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceSummariesByIds()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceSummariesByIds_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceSummariesByIds_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceSummariesByIds failed: unknown result");
  }

  public function getTraceCombosByIds($trace_ids, $adjust)
  {
    $this->send_getTraceCombosByIds($trace_ids, $adjust);
    return $this->recv_getTraceCombosByIds();
  }

  public function send_getTraceCombosByIds($trace_ids, $adjust)
  {
    $args = new ZipkinQuery_getTraceCombosByIds_args();
    $args->trace_ids = $trace_ids;
    $args->adjust = $adjust;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceCombosByIds', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceCombosByIds', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceCombosByIds()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceCombosByIds_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceCombosByIds_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceCombosByIds failed: unknown result");
  }

  public function getServiceNames()
  {
    $this->send_getServiceNames();
    return $this->recv_getServiceNames();
  }

  public function send_getServiceNames()
  {
    $args = new ZipkinQuery_getServiceNames_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getServiceNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getServiceNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getServiceNames()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getServiceNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getServiceNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getServiceNames failed: unknown result");
  }

  public function getSpanNames($service_name)
  {
    $this->send_getSpanNames($service_name);
    return $this->recv_getSpanNames();
  }

  public function send_getSpanNames($service_name)
  {
    $args = new ZipkinQuery_getSpanNames_args();
    $args->service_name = $service_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getSpanNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getSpanNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getSpanNames()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getSpanNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getSpanNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getSpanNames failed: unknown result");
  }

  public function setTraceTimeToLive($trace_id, $ttl_seconds)
  {
    $this->send_setTraceTimeToLive($trace_id, $ttl_seconds);
    $this->recv_setTraceTimeToLive();
  }

  public function send_setTraceTimeToLive($trace_id, $ttl_seconds)
  {
    $args = new ZipkinQuery_setTraceTimeToLive_args();
    $args->trace_id = $trace_id;
    $args->ttl_seconds = $ttl_seconds;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'setTraceTimeToLive', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('setTraceTimeToLive', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_setTraceTimeToLive()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_setTraceTimeToLive_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_setTraceTimeToLive_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function getTraceTimeToLive($trace_id)
  {
    $this->send_getTraceTimeToLive($trace_id);
    return $this->recv_getTraceTimeToLive();
  }

  public function send_getTraceTimeToLive($trace_id)
  {
    $args = new ZipkinQuery_getTraceTimeToLive_args();
    $args->trace_id = $trace_id;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTraceTimeToLive', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTraceTimeToLive', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTraceTimeToLive()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTraceTimeToLive_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTraceTimeToLive_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTraceTimeToLive failed: unknown result");
  }

  public function getDataTimeToLive()
  {
    $this->send_getDataTimeToLive();
    return $this->recv_getDataTimeToLive();
  }

  public function send_getDataTimeToLive()
  {
    $args = new ZipkinQuery_getDataTimeToLive_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getDataTimeToLive', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getDataTimeToLive', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getDataTimeToLive()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getDataTimeToLive_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getDataTimeToLive_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getDataTimeToLive failed: unknown result");
  }

  public function getDependencies($start_time, $end_time)
  {
    $this->send_getDependencies($start_time, $end_time);
    return $this->recv_getDependencies();
  }

  public function send_getDependencies($start_time, $end_time)
  {
    $args = new ZipkinQuery_getDependencies_args();
    $args->start_time = $start_time;
    $args->end_time = $end_time;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getDependencies', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getDependencies', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getDependencies()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getDependencies_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getDependencies_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getDependencies failed: unknown result");
  }

  public function getTopAnnotations($service_name)
  {
    $this->send_getTopAnnotations($service_name);
    return $this->recv_getTopAnnotations();
  }

  public function send_getTopAnnotations($service_name)
  {
    $args = new ZipkinQuery_getTopAnnotations_args();
    $args->service_name = $service_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTopAnnotations', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTopAnnotations', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTopAnnotations()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTopAnnotations_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTopAnnotations_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTopAnnotations failed: unknown result");
  }

  public function getTopKeyValueAnnotations($service_name)
  {
    $this->send_getTopKeyValueAnnotations($service_name);
    return $this->recv_getTopKeyValueAnnotations();
  }

  public function send_getTopKeyValueAnnotations($service_name)
  {
    $args = new ZipkinQuery_getTopKeyValueAnnotations_args();
    $args->service_name = $service_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTopKeyValueAnnotations', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTopKeyValueAnnotations', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTopKeyValueAnnotations()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'ZipkinQuery_getTopKeyValueAnnotations_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new ZipkinQuery_getTopKeyValueAnnotations_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("getTopKeyValueAnnotations failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class ZipkinQuery_getTraceIds_args {
  static $_TSPEC;

  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => 'QueryRequest',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['request'])) {
        $this->request = $vals['request'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIds_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->request = new QueryRequest();
            $xfer += $this->request->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIds_args');
    if ($this->request !== null) {
      if (!is_object($this->request)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('request', TType::STRUCT, 1);
      $xfer += $this->request->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIds_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'QueryResponse',
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIds_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new QueryResponse();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIds_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsBySpanName_args {
  static $_TSPEC;

  public $service_name = null;
  public $span_name = null;
  public $end_ts = null;
  public $limit = null;
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'span_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'end_ts',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'limit',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['span_name'])) {
        $this->span_name = $vals['span_name'];
      }
      if (isset($vals['end_ts'])) {
        $this->end_ts = $vals['end_ts'];
      }
      if (isset($vals['limit'])) {
        $this->limit = $vals['limit'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsBySpanName_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->span_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->limit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsBySpanName_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->span_name !== null) {
      $xfer += $output->writeFieldBegin('span_name', TType::STRING, 2);
      $xfer += $output->writeString($this->span_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_ts !== null) {
      $xfer += $output->writeFieldBegin('end_ts', TType::I64, 4);
      $xfer += $output->writeI64($this->end_ts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limit !== null) {
      $xfer += $output->writeFieldBegin('limit', TType::I32, 5);
      $xfer += $output->writeI32($this->limit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 6);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsBySpanName_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsBySpanName_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size67 = 0;
            $_etype70 = 0;
            $xfer += $input->readListBegin($_etype70, $_size67);
            for ($_i71 = 0; $_i71 < $_size67; ++$_i71)
            {
              $elem72 = null;
              $xfer += $input->readI64($elem72);
              $this->success []= $elem72;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsBySpanName_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter73)
          {
            $xfer += $output->writeI64($iter73);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsByServiceName_args {
  static $_TSPEC;

  public $service_name = null;
  public $end_ts = null;
  public $limit = null;
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_ts',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'limit',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['end_ts'])) {
        $this->end_ts = $vals['end_ts'];
      }
      if (isset($vals['limit'])) {
        $this->limit = $vals['limit'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsByServiceName_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->limit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsByServiceName_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_ts !== null) {
      $xfer += $output->writeFieldBegin('end_ts', TType::I64, 3);
      $xfer += $output->writeI64($this->end_ts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limit !== null) {
      $xfer += $output->writeFieldBegin('limit', TType::I32, 4);
      $xfer += $output->writeI32($this->limit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 5);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsByServiceName_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsByServiceName_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size74 = 0;
            $_etype77 = 0;
            $xfer += $input->readListBegin($_etype77, $_size74);
            for ($_i78 = 0; $_i78 < $_size74; ++$_i78)
            {
              $elem79 = null;
              $xfer += $input->readI64($elem79);
              $this->success []= $elem79;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsByServiceName_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter80)
          {
            $xfer += $output->writeI64($iter80);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsByAnnotation_args {
  static $_TSPEC;

  public $service_name = null;
  public $annotation = null;
  public $value = null;
  public $end_ts = null;
  public $limit = null;
  public $order = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'annotation',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'end_ts',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'limit',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['annotation'])) {
        $this->annotation = $vals['annotation'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['end_ts'])) {
        $this->end_ts = $vals['end_ts'];
      }
      if (isset($vals['limit'])) {
        $this->limit = $vals['limit'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsByAnnotation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->annotation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_ts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->limit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsByAnnotation_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->annotation !== null) {
      $xfer += $output->writeFieldBegin('annotation', TType::STRING, 2);
      $xfer += $output->writeString($this->annotation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_ts !== null) {
      $xfer += $output->writeFieldBegin('end_ts', TType::I64, 5);
      $xfer += $output->writeI64($this->end_ts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limit !== null) {
      $xfer += $output->writeFieldBegin('limit', TType::I32, 6);
      $xfer += $output->writeI32($this->limit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 7);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceIdsByAnnotation_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceIdsByAnnotation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size81 = 0;
            $_etype84 = 0;
            $xfer += $input->readListBegin($_etype84, $_size81);
            for ($_i85 = 0; $_i85 < $_size81; ++$_i85)
            {
              $elem86 = null;
              $xfer += $input->readI64($elem86);
              $this->success []= $elem86;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceIdsByAnnotation_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter87)
          {
            $xfer += $output->writeI64($iter87);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_tracesExist_args {
  static $_TSPEC;

  public $trace_ids = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_tracesExist_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size88 = 0;
            $_etype91 = 0;
            $xfer += $input->readListBegin($_etype91, $_size88);
            for ($_i92 = 0; $_i92 < $_size88; ++$_i92)
            {
              $elem93 = null;
              $xfer += $input->readI64($elem93);
              $this->trace_ids []= $elem93;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_tracesExist_args');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter94)
          {
            $xfer += $output->writeI64($iter94);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_tracesExist_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::SET,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_tracesExist_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::SET) {
            $this->success = array();
            $_size95 = 0;
            $_etype98 = 0;
            $xfer += $input->readSetBegin($_etype98, $_size95);
            for ($_i99 = 0; $_i99 < $_size95; ++$_i99)
            {
              $elem100 = null;
              $xfer += $input->readI64($elem100);
              if (is_scalar($elem100)) {
                $this->success[$elem100] = true;
              } else {
                $this->success []= $elem100;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_tracesExist_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::SET, 0);
      {
        $output->writeSetBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter101 => $iter102)
          {
            if (is_scalar($iter102)) {
            $xfer += $output->writeI64($iter101);
            } else {
            $xfer += $output->writeI64($iter102);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTracesByIds_args {
  static $_TSPEC;

  public $trace_ids = null;
  public $adjust = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'adjust',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
      if (isset($vals['adjust'])) {
        $this->adjust = $vals['adjust'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTracesByIds_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size103 = 0;
            $_etype106 = 0;
            $xfer += $input->readListBegin($_etype106, $_size103);
            for ($_i107 = 0; $_i107 < $_size103; ++$_i107)
            {
              $elem108 = null;
              $xfer += $input->readI64($elem108);
              $this->trace_ids []= $elem108;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->adjust = array();
            $_size109 = 0;
            $_etype112 = 0;
            $xfer += $input->readListBegin($_etype112, $_size109);
            for ($_i113 = 0; $_i113 < $_size109; ++$_i113)
            {
              $elem114 = null;
              $xfer += $input->readI32($elem114);
              $this->adjust []= $elem114;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTracesByIds_args');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter115)
          {
            $xfer += $output->writeI64($iter115);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->adjust !== null) {
      if (!is_array($this->adjust)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('adjust', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->adjust));
        {
          foreach ($this->adjust as $iter116)
          {
            $xfer += $output->writeI32($iter116);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTracesByIds_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Trace',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTracesByIds_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size117 = 0;
            $_etype120 = 0;
            $xfer += $input->readListBegin($_etype120, $_size117);
            for ($_i121 = 0; $_i121 < $_size117; ++$_i121)
            {
              $elem122 = null;
              $elem122 = new Trace();
              $xfer += $elem122->read($input);
              $this->success []= $elem122;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTracesByIds_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter123)
          {
            $xfer += $iter123->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceTimelinesByIds_args {
  static $_TSPEC;

  public $trace_ids = null;
  public $adjust = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'adjust',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
      if (isset($vals['adjust'])) {
        $this->adjust = $vals['adjust'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceTimelinesByIds_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size124 = 0;
            $_etype127 = 0;
            $xfer += $input->readListBegin($_etype127, $_size124);
            for ($_i128 = 0; $_i128 < $_size124; ++$_i128)
            {
              $elem129 = null;
              $xfer += $input->readI64($elem129);
              $this->trace_ids []= $elem129;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->adjust = array();
            $_size130 = 0;
            $_etype133 = 0;
            $xfer += $input->readListBegin($_etype133, $_size130);
            for ($_i134 = 0; $_i134 < $_size130; ++$_i134)
            {
              $elem135 = null;
              $xfer += $input->readI32($elem135);
              $this->adjust []= $elem135;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceTimelinesByIds_args');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter136)
          {
            $xfer += $output->writeI64($iter136);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->adjust !== null) {
      if (!is_array($this->adjust)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('adjust', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->adjust));
        {
          foreach ($this->adjust as $iter137)
          {
            $xfer += $output->writeI32($iter137);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceTimelinesByIds_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TraceTimeline',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceTimelinesByIds_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size138 = 0;
            $_etype141 = 0;
            $xfer += $input->readListBegin($_etype141, $_size138);
            for ($_i142 = 0; $_i142 < $_size138; ++$_i142)
            {
              $elem143 = null;
              $elem143 = new TraceTimeline();
              $xfer += $elem143->read($input);
              $this->success []= $elem143;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceTimelinesByIds_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter144)
          {
            $xfer += $iter144->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceSummariesByIds_args {
  static $_TSPEC;

  public $trace_ids = null;
  public $adjust = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'adjust',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
      if (isset($vals['adjust'])) {
        $this->adjust = $vals['adjust'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceSummariesByIds_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size145 = 0;
            $_etype148 = 0;
            $xfer += $input->readListBegin($_etype148, $_size145);
            for ($_i149 = 0; $_i149 < $_size145; ++$_i149)
            {
              $elem150 = null;
              $xfer += $input->readI64($elem150);
              $this->trace_ids []= $elem150;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->adjust = array();
            $_size151 = 0;
            $_etype154 = 0;
            $xfer += $input->readListBegin($_etype154, $_size151);
            for ($_i155 = 0; $_i155 < $_size151; ++$_i155)
            {
              $elem156 = null;
              $xfer += $input->readI32($elem156);
              $this->adjust []= $elem156;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceSummariesByIds_args');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter157)
          {
            $xfer += $output->writeI64($iter157);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->adjust !== null) {
      if (!is_array($this->adjust)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('adjust', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->adjust));
        {
          foreach ($this->adjust as $iter158)
          {
            $xfer += $output->writeI32($iter158);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceSummariesByIds_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TraceSummary',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceSummariesByIds_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size159 = 0;
            $_etype162 = 0;
            $xfer += $input->readListBegin($_etype162, $_size159);
            for ($_i163 = 0; $_i163 < $_size159; ++$_i163)
            {
              $elem164 = null;
              $elem164 = new TraceSummary();
              $xfer += $elem164->read($input);
              $this->success []= $elem164;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceSummariesByIds_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter165)
          {
            $xfer += $iter165->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceCombosByIds_args {
  static $_TSPEC;

  public $trace_ids = null;
  public $adjust = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_ids',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'adjust',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_ids'])) {
        $this->trace_ids = $vals['trace_ids'];
      }
      if (isset($vals['adjust'])) {
        $this->adjust = $vals['adjust'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceCombosByIds_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->trace_ids = array();
            $_size166 = 0;
            $_etype169 = 0;
            $xfer += $input->readListBegin($_etype169, $_size166);
            for ($_i170 = 0; $_i170 < $_size166; ++$_i170)
            {
              $elem171 = null;
              $xfer += $input->readI64($elem171);
              $this->trace_ids []= $elem171;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->adjust = array();
            $_size172 = 0;
            $_etype175 = 0;
            $xfer += $input->readListBegin($_etype175, $_size172);
            for ($_i176 = 0; $_i176 < $_size172; ++$_i176)
            {
              $elem177 = null;
              $xfer += $input->readI32($elem177);
              $this->adjust []= $elem177;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceCombosByIds_args');
    if ($this->trace_ids !== null) {
      if (!is_array($this->trace_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('trace_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::I64, count($this->trace_ids));
        {
          foreach ($this->trace_ids as $iter178)
          {
            $xfer += $output->writeI64($iter178);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->adjust !== null) {
      if (!is_array($this->adjust)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('adjust', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->adjust));
        {
          foreach ($this->adjust as $iter179)
          {
            $xfer += $output->writeI32($iter179);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceCombosByIds_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TraceCombo',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceCombosByIds_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size180 = 0;
            $_etype183 = 0;
            $xfer += $input->readListBegin($_etype183, $_size180);
            for ($_i184 = 0; $_i184 < $_size180; ++$_i184)
            {
              $elem185 = null;
              $elem185 = new TraceCombo();
              $xfer += $elem185->read($input);
              $this->success []= $elem185;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceCombosByIds_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter186)
          {
            $xfer += $iter186->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getServiceNames_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ZipkinQuery_getServiceNames_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getServiceNames_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getServiceNames_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getServiceNames_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::SET) {
            $this->success = array();
            $_size187 = 0;
            $_etype190 = 0;
            $xfer += $input->readSetBegin($_etype190, $_size187);
            for ($_i191 = 0; $_i191 < $_size187; ++$_i191)
            {
              $elem192 = null;
              $xfer += $input->readString($elem192);
              if (is_scalar($elem192)) {
                $this->success[$elem192] = true;
              } else {
                $this->success []= $elem192;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getServiceNames_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::SET, 0);
      {
        $output->writeSetBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter193 => $iter194)
          {
            if (is_scalar($iter194)) {
            $xfer += $output->writeString($iter193);
            } else {
            $xfer += $output->writeString($iter194);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getSpanNames_args {
  static $_TSPEC;

  public $service_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getSpanNames_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getSpanNames_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getSpanNames_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getSpanNames_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::SET) {
            $this->success = array();
            $_size195 = 0;
            $_etype198 = 0;
            $xfer += $input->readSetBegin($_etype198, $_size195);
            for ($_i199 = 0; $_i199 < $_size195; ++$_i199)
            {
              $elem200 = null;
              $xfer += $input->readString($elem200);
              if (is_scalar($elem200)) {
                $this->success[$elem200] = true;
              } else {
                $this->success []= $elem200;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getSpanNames_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::SET, 0);
      {
        $output->writeSetBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter201 => $iter202)
          {
            if (is_scalar($iter202)) {
            $xfer += $output->writeString($iter201);
            } else {
            $xfer += $output->writeString($iter202);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_setTraceTimeToLive_args {
  static $_TSPEC;

  public $trace_id = null;
  public $ttl_seconds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_id',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'ttl_seconds',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_id'])) {
        $this->trace_id = $vals['trace_id'];
      }
      if (isset($vals['ttl_seconds'])) {
        $this->ttl_seconds = $vals['ttl_seconds'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_setTraceTimeToLive_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->ttl_seconds);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_setTraceTimeToLive_args');
    if ($this->trace_id !== null) {
      $xfer += $output->writeFieldBegin('trace_id', TType::I64, 1);
      $xfer += $output->writeI64($this->trace_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ttl_seconds !== null) {
      $xfer += $output->writeFieldBegin('ttl_seconds', TType::I32, 2);
      $xfer += $output->writeI32($this->ttl_seconds);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_setTraceTimeToLive_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_setTraceTimeToLive_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_setTraceTimeToLive_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceTimeToLive_args {
  static $_TSPEC;

  public $trace_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'trace_id',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['trace_id'])) {
        $this->trace_id = $vals['trace_id'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceTimeToLive_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceTimeToLive_args');
    if ($this->trace_id !== null) {
      $xfer += $output->writeFieldBegin('trace_id', TType::I64, 1);
      $xfer += $output->writeI64($this->trace_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTraceTimeToLive_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTraceTimeToLive_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTraceTimeToLive_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getDataTimeToLive_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ZipkinQuery_getDataTimeToLive_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getDataTimeToLive_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getDataTimeToLive_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getDataTimeToLive_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getDataTimeToLive_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getDependencies_args {
  static $_TSPEC;

  public $start_time = null;
  public $end_time = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'start_time',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'end_time',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['start_time'])) {
        $this->start_time = $vals['start_time'];
      }
      if (isset($vals['end_time'])) {
        $this->end_time = $vals['end_time'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getDependencies_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->start_time);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->end_time);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getDependencies_args');
    if ($this->start_time !== null) {
      $xfer += $output->writeFieldBegin('start_time', TType::I64, 1);
      $xfer += $output->writeI64($this->start_time);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_time !== null) {
      $xfer += $output->writeFieldBegin('end_time', TType::I64, 2);
      $xfer += $output->writeI64($this->end_time);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getDependencies_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'Dependencies',
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getDependencies_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new Dependencies();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getDependencies_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTopAnnotations_args {
  static $_TSPEC;

  public $service_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTopAnnotations_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTopAnnotations_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTopAnnotations_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTopAnnotations_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size203 = 0;
            $_etype206 = 0;
            $xfer += $input->readListBegin($_etype206, $_size203);
            for ($_i207 = 0; $_i207 < $_size203; ++$_i207)
            {
              $elem208 = null;
              $xfer += $input->readString($elem208);
              $this->success []= $elem208;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTopAnnotations_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter209)
          {
            $xfer += $output->writeString($iter209);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTopKeyValueAnnotations_args {
  static $_TSPEC;

  public $service_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'service_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTopKeyValueAnnotations_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTopKeyValueAnnotations_args');
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 1);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ZipkinQuery_getTopKeyValueAnnotations_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QueryException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'ZipkinQuery_getTopKeyValueAnnotations_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size210 = 0;
            $_etype213 = 0;
            $xfer += $input->readListBegin($_etype213, $_size210);
            for ($_i214 = 0; $_i214 < $_size210; ++$_i214)
            {
              $elem215 = null;
              $xfer += $input->readString($elem215);
              $this->success []= $elem215;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QueryException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ZipkinQuery_getTopKeyValueAnnotations_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter216)
          {
            $xfer += $output->writeString($iter216);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
